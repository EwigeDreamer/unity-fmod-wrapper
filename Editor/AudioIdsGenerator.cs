using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using ED.FMODWrapper.Enums;
using UnityEditor;
using UnityEditor.Compilation;
using UnityEngine;
using UnityEngine.Pool;
using Debug = UnityEngine.Debug;

namespace ED.FMODWrapper.Editor
{
    public static class AudioIdsGenerator
    {
        private const string GuidsFilePathPrefsKey = nameof(AudioIdsGenerator) + "_guids_file_path";
        private const string GeneratedFilePathPrefsKey = nameof(AudioIdsGenerator) + "_generated_file_path";
        private const string PropertyDrawerName = "PropertyDrawer";

        [MenuItem("Tools/Custom/Generate Audio IDs")]
        private static void GenerateAudioIds()
        {
            var guidsPath = PlayerPrefs.GetString(GuidsFilePathPrefsKey, Environment.CurrentDirectory);
            guidsPath = EditorUtility.OpenFilePanelWithFilters(
                "Select FMOD GUIDs.txt file",
                guidsPath,
                new[] { "Text files", "txt" });
            if (!File.Exists(guidsPath))
                throw new InvalidOperationException("GUID text file not found");
            PlayerPrefs.SetString(GuidsFilePathPrefsKey, guidsPath);
            
            var data = File.ReadAllText(guidsPath);
            var matches = Regex.Matches(data, @"(?<guid>{\S+})\s+(?<full_path>(?<type>\S+):/(?<path>[\S ]*))");

            var tree = new Node("AudioIds", matches
                .GroupBy(a => a.Groups["type"].Value)
                .Select(a => new Node(
                    ToFancyName(a.Key),
                    GetBaseEnumType(a.Key),
                    a
                        .Select(b => new IdData(
                            b.Groups["path"].Value.Split('/'),
                            b.Groups["full_path"].Value,
                            b.Groups["guid"].Value))
                        .ToList()))
                .ToList());

            var fileName = tree.Name;
            var fileText = GenerateScript(tree);
            var filePath = PlayerPrefs.GetString(GeneratedFilePathPrefsKey, Application.dataPath);
            filePath = EditorUtility.SaveFilePanelInProject(
                $"Save generated script...",
                fileName,
                "cs",
                "Please, choose the place to save generated script",
                Path.GetDirectoryName(filePath));
            if (string.IsNullOrWhiteSpace(filePath))
                return;
            PlayerPrefs.SetString(GeneratedFilePathPrefsKey, filePath);
            PrepareDirectory(filePath);
            if (File.Exists(filePath)) File.Delete(filePath);
            File.WriteAllText(filePath, fileText, Encoding.UTF8);
            Debug.Log($"Script was successfully saved on path {filePath}");
            AssetDatabase.ImportAsset(filePath);
            CompilationPipeline.RequestScriptCompilation();
        }

        private static void PrepareDirectory(string fullPath)
        {
            var directories = Path.GetDirectoryName(fullPath)!
                .Split(
                    new[]
                    {
                        Path.DirectorySeparatorChar,
                        Path.AltDirectorySeparatorChar
                    },
                    StringSplitOptions.RemoveEmptyEntries);
            for (var i = 1; i < directories.Length; ++i)
                directories[i] = Path.Combine(directories[i - 1], directories[i]);
            foreach (var directory in directories)
                if (!Directory.Exists(directory))
                    Directory.CreateDirectory(directory);
        }

        private static string GenerateScript(Node tree)
        {
            var sb = new System.Text.StringBuilder();
            
            sb.AppendLine($"// This script was generated by {typeof(AudioIdsGenerator).FullName}");
            sb.AppendLine();
            sb.AppendLine(GenerateUsingType(typeof(BaseAudioBankId)));
            sb.AppendLine(GenerateUsingType(typeof(BaseAudioBusId)));
            sb.AppendLine(GenerateUsingType(typeof(BaseAudioEventId)));
            sb.AppendLine(GenerateUsingType(typeof(BaseAudioParameterId)));
            sb.AppendLine(GenerateUsingType(typeof(BaseAudioSnapshotId)));
            sb.AppendLine(GenerateUsingType(typeof(BaseAudioVcaId)));
            sb.AppendLine(GenerateUsingType(typeof(BaseAudioId)));
            sb.AppendLine(GenerateUsingType(typeof(FMOD.GUID)));
            sb.AppendLine();
            sb.AppendLine($"namespace {typeof(AudioService).Namespace}");
            sb.AppendLine("{");
            
            FillDataRecursively(tree, sb, 1);
            
            sb.AppendLine("}");

            return sb.ToString();

            string GenerateUsingType(Type type) => $"using {type.Name} = {type.Namespace}.{type.Name};";
        }

        private static void FillDataRecursively(Node node, System.Text.StringBuilder sb, int level)
        {
            var className = node.Name;
            var indent = new string(' ', level * 4);
            var internalIndent = new string(' ', (level + 1) * 4);
            var needInherit = node.BaseType != null && node.Fields.Count > 0;
            
            sb.Append(indent);
            if (needInherit) sb.Append($"[{typeof(SerializableAttribute).FullName}] public sealed class {className} : {node.BaseType.Name}");
            else sb.Append($"public static class {className}");
            sb.AppendLine();
            
            sb.Append(indent);
            sb.AppendLine("{");

            if (needInherit)
            {
                sb.Append(internalIndent);
                sb.Append($"private {className}(string name, {nameof(FMOD.GUID)} guid) : base(name, guid) {{ }}");
                sb.AppendLine();
                sb.AppendLine();
            }
            
            using (var h = HashSetPool<string>.Get(out var fieldNames))
            {
                foreach (var field in node.Fields)
                {
                    var fieldName = field.Name;
                    if (string.IsNullOrWhiteSpace(fieldName)) fieldName = "_NoName";
                    if (fieldName == className) fieldName = '_' + fieldName;
                    if (node.Children.Any(a => a.Name == fieldName)) fieldName = '_' + fieldName;
                    while (fieldNames.Contains(fieldName)) fieldName = '_' + fieldName;
                    fieldNames.Add(fieldName);
                    sb.Append(internalIndent);
                    sb.Append($"public static readonly {className} {fieldName} = new {className}(");
                    sb.Append($"@\"{field.Path}\"");
                    sb.Append(", ");
                    sb.Append($"{nameof(FMOD.GUID)}.{nameof(FMOD.GUID.Parse)}(@\"{field.Guid}\")");
                    sb.Append($");");
                    sb.AppendLine();
                }
            }

            if (node.Fields.Count > 0)
            {
                sb.AppendLine();
                sb.AppendLine("#if UNITY_EDITOR");
                sb.Append(internalIndent);
                sb.Append($"[{typeof(CustomPropertyDrawer).FullName}(typeof({className}))] private class {PropertyDrawerName} : {PropertyDrawerName}<{className}> {{ }}");
                sb.AppendLine();
                sb.AppendLine("#endif");
            }

            var needSpace = node.Fields.Count > 0;
            foreach (var child in node.Children)
            {
                if (needSpace) sb.AppendLine();
                FillDataRecursively(child, sb, level + 1);
                needSpace = true;
            }
            
            sb.Append(indent);
            sb.AppendLine("}");
        }

        private static string ToFancyName(string original)
        {
            var result = ToPascalCase(original);
            if (new Regex("^[0-9]").IsMatch(result)) result = '_' + result;
            return result;
        }
        
        /// <summary>
        /// https://stackoverflow.com/questions/18627112/how-can-i-convert-text-to-pascal-case
        /// </summary>
        private static string ToPascalCase(string original)
        {
            Regex invalidCharsRgx = new Regex("[^_a-zA-Z0-9]");
            Regex whiteSpace = new Regex(@"(?<=\s)");
            Regex punctuation = new Regex(@"\p{P}"); // my improvement
            Regex startsWithLowerCaseChar = new Regex("^[a-z]");
            Regex firstCharFollowedByUpperCasesOnly = new Regex("(?<=[A-Z])[A-Z0-9]+$");
            Regex lowerCaseNextToNumber = new Regex("(?<=[0-9])[a-z]");
            Regex upperCaseInside = new Regex("(?<=[A-Z])[A-Z]+?((?=[A-Z][a-z])|(?=[0-9]))");

            // replace white spaces with undescore, then replace all invalid chars with empty string
            original = whiteSpace.Replace(original, "_");
            original = punctuation.Replace(original, "_");
            var pascalCase = invalidCharsRgx.Replace(original, string.Empty)
                // split by underscores
                .Split(new char[] { '_' }, StringSplitOptions.RemoveEmptyEntries)
                // set first letter to uppercase
                .Select(w => startsWithLowerCaseChar.Replace(w, m => m.Value.ToUpper()))
                // replace second and all following upper case letters to lower if there is no next lower (ABC -> Abc)
                .Select(w => firstCharFollowedByUpperCasesOnly.Replace(w, m => m.Value.ToLower()))
                // set upper case the first lower case following a number (Ab9cd -> Ab9Cd)
                .Select(w => lowerCaseNextToNumber.Replace(w, m => m.Value.ToUpper()))
                // lower second and next upper case letters except the last if it follows by any lower (ABcDEf -> AbcDef)
                .Select(w => upperCaseInside.Replace(w, m => m.Value.ToLower()));

            return string.Concat(pascalCase);
        }

        private static Type GetBaseEnumType(string key)
        {
            return key switch
            {
                "bank" => typeof(BaseAudioBankId),
                "bus" => typeof(BaseAudioBusId),
                "event" => typeof(BaseAudioEventId),
                "parameter" => typeof(BaseAudioParameterId),
                "snapshot" => typeof(BaseAudioSnapshotId),
                "vca" => typeof(BaseAudioVcaId),
                _ => typeof(BaseAudioId)
            };
        }

        private class IdData
        {
            public readonly string[] TreePath;
            public readonly string Path;
            public readonly string Guid;

            public IdData(string[] treePath, string path, string guid)
            {
                TreePath = treePath;
                Path = path;
                Guid = guid;
            }
        }
        
        private class Node
        {
            public readonly string Name;
            public readonly Type BaseType;
            public readonly List<Node> Children;
            public readonly List<Field> Fields;

            public Node(string name, List<Node> children)
            {
                Name = name;
                BaseType = null;
                Children = children.ToList();
                Fields = new List<Field>();
            }

            public Node(string name, Type baseType, List<IdData> data)
            {
                Name = name;
                BaseType = baseType;
                Children = data
                    .Where(a => a.TreePath.Length > 1)
                    .GroupBy(a => a.TreePath[0])
                    .Select(a => new Node(ToFancyName(a.Key), baseType, a.Select(b => new IdData(b.TreePath.Skip(1).ToArray(), b.Path, b.Guid)).ToList()))
                    .ToList();
                Fields = data
                    .Where(a => a.TreePath.Length == 1)
                    .Select(a => new Field(ToFancyName(a.TreePath[0]), a.Path, a.Guid))
                    .ToList();
            }
        }

        private class Field
        {
            public readonly string Name;
            public readonly string Path;
            public readonly string Guid;

            public Field(string name, string path, string guid)
            {
                Name = name;
                Path = path;
                Guid = guid;
            }
        }
    }
}